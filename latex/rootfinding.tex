Our expressions are represented using something known as an abstract syntax tree (AST). ASTs are useful for representing things that can be written as grammars, such as the expressions we allow.
\begin{figure}[H]
	\input{fig-astExample}
	\caption{Example AST for $cos(z)+e^{4iz}+2/(z^2log(z))$. \\ Note that Sum takes the sum of all of its children, and that Term takes the product of all of its children. Also note that multiplication by a constant takes place in Sums and not Terms. }
	\label{fig:astExample}
\end{figure}
\noindent As you can see in Figure~\ref{fig:astExample}, ASTs can show expressions in a surprisingly intuitive way. To find roots on an AST, the first thing we do is simplify it. We perform simplification on ASTs using rules. These rules say that if a subtree of the AST has some property, then part of it can be replaced with a simplified AST. Some of the rules we use are constant evaluation, removal of things with a coefficient of zero in a Sum, and removal of things with a power of one in a Term. We can't use all of the rules from the real numbers. For example, we allow the simplification $e^{log(z)}\to z$, but not $log(e^z)\to z$, because $log$ is a multivalued function (we could simplify $log(e^z)\to z+2n\pi i$, but this rule was never implemented). We don't have any simplification rules that implement factoring, so we can't successfully simplify the expression $z/(z^2-z)\to 1/(z-1)$, so our algorithms produce incorrect results on such expressions.

We implemented a routine that tried to find where two expressions were equal. To find roots, we ran this routine to find where an expression equaled zero. Our solving routine worked by trying to solve the outermost expression on the right hand side, and calling itself recursively on the input to the outermost expression. For example, when trying to solve $sin(1/z)=0$, we find that $sin(z)=0$ when $z=n\pi$, and then we try to solve $1/z=n\pi$. This doesn't work when trying to solve Sums of more than one expression, or when trying to solve Terms for anything other than zero. We were unable to come up with an algorithm for doing this, so our algorithm simply reports the equations it was unable to solve. WolframAlpha and Maple have similar problems, but they are able to solve more equations with sums and products, and often report numerical solutions when they are unable to solve.
